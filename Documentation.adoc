:toc: left

:source-highlighter: prettify

// Macro definitions for this file only
:source: Documentation.adoc[Source Text]

include::MainMenu.adoc[]

Please click on the following links to refer the technical documentaion.

.More to Come
NOTE: Please keep checking this section frequently for more updates.

== Introduction
The following sections outlines the different options available while configuring an application.

== View Config Annotations


.View Components
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Component | Description |Attributes |Notes

|Page |Used to create a view page | Type - Home,Details,Form,Static |
Default value will be Home.

|Tile |Used to create a view Tile | Size - XSmall,Small,Medium,Large |
Default value will be Large.

|Section |Used to create a view Section. A section is encapsulated in a tile | Size - XSmall,Small,Medium,Large |
Default value will be Large.

|Form |Used to create a view Form to capture user responses. A forn is encapsulated in a section | |


|=========================================================


.ViewStyle Component

ViewParamBehavior component is used to define an ANNOTATION_TYPE level annotation that is used with
all most of the annotations described below.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target(value={ElementType.ANNOTATION_TYPE})
	@Inherited
	public @interface ViewStyle {

	}
----

NOTE: The above code is the definition if ViewStyle component. As you can see, ElementType.ANNOTATION_TYPE determines that this annotation can only be used
in other annotations.

Here is an example: -

[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.TYPE})
	@ViewStyle
	public @interface ViewRoot {
		String alias() default "root";
		String layout() default "";
	}
----


=== Accordion

.Accordion Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | Accordion |cannot be changed
|cssClass |String |  | css class override where default is 'panel-default'

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Accordion.java
----
@Accordion
private VASectionA_Questionnaire vaSectionA_Questionnaire;
----

NOTE: Accordion is supported only in a form


=== AccordionGroup

.AccordionGroup Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | AccordionGroup |cannot be changed
|cssClass |String | panel-default | css class override where default is 'panel-default'

|=========================================================


=== Button

.Button Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | Button |cannot be changed
|url |String |  | source url of the button element
|b |String | $execute | b
|method |String | GET | HTTP method that will be executed
|imgSrc |String |  | source path/ url of the image
|type |enum | Type.Plain| type of button
|payload |String |  | payload
|cssClass |String | btn btn-primary| class used to style the section
|formReset |boolean |true | reset the form

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Button.java
----
@Config(url="/pageAddEditGoal/tileEditGoal/sectionEditGoal/goalDetailsForm/_nav?pageId=pageCarePlanSummary")
@Button(type = Button.Type.DESTRUCTIVE)
private String delete;
----

NOTE: The possible enum values for size are *PRIMARY, SECONDARY, PLAIN, DESTRUCTIVE* +
_Please read @Config for information regarding @Config annotation._


=== ButtonGroup

.ButtonGroup Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | ButtonGroup |cannot be changed
|cssClass |String | text-sm-right| class used to style the section

|=========================================================


[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ButtonGroup.java
----
@ButtonGroup
private FormGoalsButtonGroup formGoalsButtonGroup;
----

=== CardDetail

.CardDetail Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | CardDetail |cannot be changed
|cssClass |String | contentBox right-gutter bg-light mt-1 |class used to style the CardDetail
|imgSrc |String |  | source path/ url of the image
|editable |boolean |false | make the component editable
|modelPath |String |  |specify the model path for CardDetail
|title |String |  | specify the title of the CardDetail
|draggable |boolean |false | determine of the CardDetailsGrid is draggable

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CardDetail.java
----
@CardDetail(title="Member Overview", cssClass="contentBox right-gutter bg-alternate mt-0")
private CardDetailMember cardDetailMember;
----

NOTE: *contentBox right-gutter bg-alternate mt-0* overrides the default cssClass specified for the CardDetail

==== CardDetail Children Components
CardDetail has several children components that nested level components can utilize to break the component into logical sections.

[source,java]
.CardDetailChildren.java
----
@Model
@Getter @Setter
public static class MyCard {

	@CardDetail.Header
	MyCardDetailTag myCardTag;

	@CardDetail.Body
	MyCardDetailBody myCardBody;
}

@Model
@Getter @Setter
public static class MyCardDetailTag { ... }

@Model
@Getter @Setter
public static class MyCardDetailBody { ... }
----

===== CardDetail.Body

---

See the available CardDetail children components below:

.CardDetail.Body Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type		| Default 			| Description

| alias 		| String 	| CardDetailsBody 	| cannot be changed
| cssClass 		| String 	| 					| class used to style the component

|=========================================================

===== CardDetail.Footer

.CardDetail.Footer Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type		| Default 				| Description

| alias 		| String 	| CardDetailsFooter 	| cannot be changed
| cssClass 		| String 	| 						| class used to style the component

|=========================================================

===== CardDetail.Header

.CardDetail.Header Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type		| Default 				| Description

| alias 		| String 	| CardDetailsHeader 	| cannot be changed
| cssClass 		| String 	| 						| class used to style the component

|=========================================================

===== CardDetail.Tag

.CardDetail.Tag Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type		| Default 			| Description

| alias 		| String 	| CardDetailsTag 	| cannot be changed
| cssClass 		| String 	| 					| class used to style the component

|=========================================================

=== CardDetailsGrid

.CardDetailsGrid Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | CardDetailsGrid |cannot be changed
|editUrl |String |  |
|draggable |boolean |false | determine of the CardDetailsGrid is draggable
|onLoad |boolean |false | specify the behaviour of CardDetailsGrid during page load

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CardDetailsGrid.java
----
@CardDetailsGrid(onLoad=true, draggable=true)
@Config(url="/pageHealthConcerns/tileHealthConcerns/sectionConcerns/concernsCards.m/_process?fn=_set&url=/p/cmcase/_search?fn=query&where=cmcase.id.eq('<!/.m/id!>')&project=/healthProblemsEnclosed")
@Path(linked=false)
private List<CardDetailConcerns> concernsCards;
----

NOTE: *onLoad=true* and *draggable=true* will override the default false values for onLoad and draggable respectively. +
_For information regarding @Config, please read View Configuration Annotations section_

=== CheckBox

.CheckBox Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | CheckBox |cannot be changed
|cssClass |String |  |class used to style the CheckBox
|labelClass |String | anthem-label |class used to style the CheckBox label
|postEventOnChange |boolean | false |post the value to the server onblur
|controlId |String |  |currently not in use except for assessments where this signifies the question number
|help |String | | help text that will be displayed in tooltip component

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CheckBox.java
----
@CheckBox(postEventOnChange=true)
private boolean admin;
----

NOTE: *postEventOnChange=true* will override the default false value of postEventOnChange.

=== CheckBoxGroup
CheckBoxGroup can be used for multi-select checkboxes.

.CheckBoxGroup Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | CheckBoxGroup |cannot be changed
|cssClass |String |  |class used to style the CheckBox
|labelClass |String | anthem-label |class used to style the CheckBox label
|postEventOnChange |boolean | false |post the value to the server onblur
|controlId |String |  |
|help |String | | help text that will be displayed in tooltip component
|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CheckBoxGroup.java
----
@CheckBoxGroup(postEventOnChange=true)
private String[] days;
----

NOTE: *postEventOnChange=true* will override the default false value of postEventOnChange.
*DataType* for checkboxgroup attribute should be *String[]* to hold multiple values.

=== ComboBox

.ComboBox Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | ComboBox |cannot be changed
|readOnly |boolean | false| make the component readonly
|labelClass |String | anthem-label| class used to style the label
|postEventOnChange |boolean | false| post the value to the server onblur
|controlId |String |  |currently not in use except for assessments where this signifies the question number
|help |String | | help text that will be displayed in tooltip component

|=========================================================


[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ComboBox.java
----
@Path
@Model.Param.Values(url="~/client/orgname/staticCodeValue/_search?fn=lookup&where=staticCodeValue.paramCode.eq('/goalCategory')")
@ComboBox
private String goalCategory;
----

NOTE: Please refer @Model in the core config annotations section.

=== Domain

.Domain Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |String |  |
|lifecycle |String |  |
|includeListeners |enum | |
|onLoad |boolean |false | specify the behaviour of CardDetailsGrid during page load

|=========================================================

NOTE: The possible enum values for includeListeners are *ListenerType.none, ListenerType.websocket, ListenerType.persistent, ListenerType.update*

_@Domain component is a part of view config as well as core config annotations._
The difference between the two is that @Domain annotation of view config does not persist any data
while @Domain annotation of core config persists data in MongoDB. +

View configuration @Domain annotation does not persist any data.
*value=Database.rep_none*  of @Repo specifies that a class with @Domain annotation does
not persist any data in database. +

For information about @Domain in core config, please refer to Core Config
Annotations section.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Domain.java
----
@Domain(value = "cmcaseview",includeListeners={ListenerType.websocket})
@MapsTo.Type(CMCase.class)
@Repo(value=Database.rep_none, cache=Cache.rep_device)
@Getter @Setter
public class VRCmCase {
}
----

=== FieldValue
[cols="4,^3,^3,10",options="header"]

A simple field which holds a value. Has the ability to become an in place edit field with several configurable properties.

|=========================================================
| Name 					| Type 		| Default 			| Description

| alias					| String 		| FieldValue		| cannot be changed
| cols					| String 		| 1					| the number of columns to display
| cssClass				| String 		| 				 	| class used to style the component
| iconField				| String 		| 		 			| adds a class 'iconField' and the value of iconField to the css class for this component
| imgSrc				| String 		| 		 			| source path/url of the image
| inPlaceEdit			| boolean 		| false	 			| whether or not to configure this field as able to be edited in place
| inPlaceEditType		| String 		| 		 			| set the Type of the in place edit component
| showName				| boolean		| true				| whether or not to show the label for this component
| value 				| Enum (Type)	| Type.Field		| classification of the link useful for determining functional behavior
| url	 				| String 		| 					| source url to operate on

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.FieldValue.java
----
@MapsTo.Type(CMGoal.class)
@Getter @Setter
public static class VCHeaderGoal {
	@FieldValue(showName=false, cols="2")
	@MapsTo.Path("/description")
	private String description;

	@FieldValue(showName=false, iconField="date")
	@MapsTo.Path("/targetDate")
	private LocalDate targetDate;

	@FieldValue(showName=false, iconField="planned")
	@MapsTo.Path("/status")
	private String goalStatus;
}
----

=== FileUpload

.FileUpload Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String |FileUpload |Cannot be changed
|type |String |.pdf,.png  |comma separated list of file types user is allowed to upload

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.FileUpload.java
----
@FileUpload(type=".png,.pdf")
private String fileUpload;
----
The above configuration allows only ".png" and ".pdf" to be uploaded by the users.
 If they try to upload other file types, an error is thrown.

=== FilterButton
[cols="4,^3,^3,10",options="header"]

A collection of buttons to operate with a configurable filter

|=========================================================
| Name 					| Type 		| Default 			| Description

| alias					| String 	| FilterButton		| cannot be changed
| b						| String 	| $execute 			| behavior to use
| cssClass				| String 	| btn btn-primary 	| class used to style the component
| imgSrc				| String 	| 		 			| source path/url of the image
| method				| String 	| GET	 			| HTTP method that will be executed
| url	 				| String 	| 					| source url to operate on

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.FilterButton.java
----
@FilterButton
private VFbAllTasks vFbAllTasks;

@Model @Getter @Setter
public static class VFbAllTasks {

	@Config(url="/vpHome/vtTasks/vsTasks/tasks.m/_process?fn=_set&url=/p/task/_search?fn=query&where=task.status.eq('Open')")
	@Button(cssClass="btn btn-secondary btn-badge")
	private String vbOpenTasks;
}
----

TIP: Decorate complex classes with @FilterButton to define behavior for child elements (e.g. vbOpenTasks in the example above.)

=== Form

.Form Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | Form |cannot be changed
|submitUrl |String |  | url that will be hit after submit
|b |String | | b
|cssClass |String | | class used to style the section
|submitButton |boolean |true | form will be submitted
|navLink |String |  | navigation link

|=========================================================


[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Form.java
----
@Form(cssClass="twoColumn")
@Path(linked=false, state=State.External)
private FormGoalDetails goalDetailsForm;
----

=== Grid

.Grid Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | Grid |cannot be changed
|onLoad |boolean |false | specify the behaviour of CardDetailsGrid during page load
|isTransient |boolean |false | specify the behaviour of CardDetailsGrid during page load
|url |String |  |specify url for the Grid
|rowSelection |boolean |false | determine if row selection is enabled on the Grid
|pageSize |String | 10 |specify the page size for the Grid
|pagination |boolean |true | determine if pagination is enabled on the Grid
|postButton |boolean |false | determine if post Button is enabled on the Grid
|postButtonUrl |String |  |specify the url of post button for the Grid
|postButtonTargetPath |String |  |Target path for the multi select rows on the grid. The payload for the selections will be created based on this path.
|postButtonAlias |String |  | Button name alias for the multiselect action on the grid
|postEventOnChange |boolean | false |post the value to the server onblur

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Grid.java
----
@Grid
@MapsTo.Path(linked=false,state=State.External)
private List<SearchPatient> patientResult;
----
[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.GridWithMultiRowSelection.java
----
Provide the postButtonUrl based on the config.

@Grid(rowSelection=true,
postButtonUrl="/view/page/tile/section/remove",
postButton=true,
postButtonTargetPath="temp_ids",
postButtonAlias="Remove")

@Path("/members")
private List<VGGroupView> vgGroupList;

@Configs({
			@Config(url="/page/tile/section/vsRemoveList/_replace"),
			@Config(url="/page/tile/section/vgGroupList/<!col!>/.m/_process?fn=_setByRule&rule=updategroup", col="<!/vsRemoveList/temp_ids!>"),
			@Config(url="<!#this!>/../vgGroupList.m/_process?fn=_set&url=/p/group/_search?fn=query&project=/members")
		})
private String remove;

private VSRemoveList vsRemoveList;

@Getter @Setter
public static class VSRemoveList {
	private List<String> temp_ids;
}
----

=== GridColumn

.GridColumn Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | GridColumn |cannot be changed
|hidden |boolean |false | Setting this to true will hide the column in the grid
|sortable |boolean |false | Enables sorting on the column
|filter |boolean | false |Setting this to true will enable a explicit filter component(Input TextBox) on the UI
|filterValue |String | | Default filterValue for a particular column.Can be used without setting filter attribute to restrict user from providing any other filter value.
|filterMode |String | equals |Mode to filter data within the column. It is defaulted to 'equals'.Current filter modes supported by the Grid component are listed as enum values - equals,contains,endsWith,in

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.GridColumn.java
----
@GridColumn(hidden=true,filterValue="false")
@Path private boolean active;
----

=== LinkMenu

LinkMenu component is used for displaying links for a grid row. LinkMenu groups the actions for a grid row and displays it as a drop down menu.
Link Menu contains @Link components. Variables can be passed in the Link URLs using {} syntax (Example below).

.LinkMenu Attributes
[cols="4,^3,^3,^3,10",options="header"]
|=========================================================
|Name 		| Type 	|Default 	|Required 	|Description

|alias 		|String | LinkMenu 	|Y 			|cannot be changed
|cssClass 	|String | false 	|N 			|custom style class

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.LinkMenu.java

----
@LinkMenu
    private VLMCaseItemLinks vlmCaseItemLinks;
   
    @Model
    @Getter @Setter
    private static class VLMCaseItemLinks {
    	@Configs({ @Config(url = "/p/cmcaseview:<!/.m/id!>/_get?b=$execute"),
			@Config(url = "/p/cmcaseview:<!/.m/id!>/_nav?pageId=pageCaseInfo") 
    	})
		@Link(imgSrc = "task.svg")
		@Label(value = "View Case")
		private String viewCase;

		@Configs({
			@Config(url = "/p/caseassignmentwithgridview/_new?fn=_initEntity&target=/vpAssignmentTask/vtTaskDetails/vsShowMycases/associatedCaseId&json=<!/.m/id!>") 
		})
		@Link(imgSrc = "task.svg")
		@Label(value = "Assign Case Owner")
		private String assignCase;

		@Link(value=Type.EXTERNAL,target="_blank",imgSrc = "task.svg" , url="http://va10dwviss323.us.ad.wellpoint.com:81/CUEDEV_Services/RxShowDocument.aspx?userid=AC633468&documentid={documentKey}")
			@MapsTo.Path(linked = false)
			private String viewDoc;
    	}
----

=== Image
[cols="4,^3,^3,10",options="header"]

An image component used for displaying images.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias 				| String 	| Image 		| cannot be changed
| imgSrc 				| String 	| 		 		| source path/ url of the image

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Image.java
----
@Image(imgSrc="/resources/img.png")
private String title;
----

=== InputDate

.InputDate Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | InputDate |cannot be changed
|readOnly |boolean |false |hide/show the component
|labelClass |String | anthem-label |class used to style the label
|type |String | date |type of input date
|postEventOnChange |boolean | false |post the value to the server onblur
|controlId |String |  |currently not in use except for assessments where this signifies the question number
|help |String | | help text that will be displayed in tooltip component

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.InputDate.java
----
@Path
@InputDate private LocalDate startDate;
----

=== InPlaceEdit
[cols="4,^3,^3,10",options="header"]

A component which allows for in-line editing of a particular field.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias 				| String 	| InPlaceEdit 	| cannot be changed
| type	 				| String 	| text	 		| the type of field being configured. Supported types are *Text*, *Textarea*, and *ComboBox*

|=========================================================

=== Label
[cols="4,^3,^3,10",options="header"]

A label component used to output descriptive text.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias 				| String 	| Label 		| cannot be changed

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Label.java
----
@Label
private String title;
----

=== Link
[cols="4,^3,^3,10",options="header"]

A hyperlink component used for navigation or user interaction of text.

Links can currently be used under the following components:  

* CardDetail
* Menu
* Section

'''

.Link Attributes
|=========================================================
| Name					| Type 			| Default 				| Description

| altText 				| String 		|  						| alternate text to be used
| b 					| String 		| $executeAnd$nav		| behavior to use
| cssClass				| String 		|  						| class used to style the component
| imgSrc 				| String 		|  						| source path/ url of the image
| method 				| String 		| GET 					| HTTP method that will be executed
| rel					| String		|						| the HTML rel attribute
| target				| String		|						| the HTML target attribute
| url 					| String 		| 		 				| source url to operate on
| value 				| Enum (Type)	| Type.Default			| classification of the link useful for determining functional behavior

|=========================================================

.Type.java
NOTE: The possible enum values for value are: *DEFAULT, EXTERNAL, MENU*.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Link.java
----
// UI Navigation to page vpHome under domain petclinic
@Link(url="/h/petclinic/vpHome")
private String linkToHome;

// Executes a request against _subscribe, and sets the image
@Link(url="/notifications/_subscribe:{id}/_process", b="$executeAnd$configAnd$nav" , method="POST")
private String subscribeToEmailNotifications;

// Creates an external link, as in a link navigating outside of the context of the Nimbus framework.
@Link(url="https://www.mywebsite.com", value = Link.Type.EXTERNAL, target="_new", rel="nofollow")
private String myWebsiteLink;
----

=== Menu
[cols="4,^3,^3,10",options="header"]

A section intended to contain other navigation components.

|=========================================================
| Name					| Type 			| Default 				| Description

| alias					| String 		| 		 				| cannot be changed
| cssClass				| String 		|  						| class used to style the component
| value 				| Enum (Type)	| Type.CONTEXT			| classification of the link useful for determining functional behavior

|=========================================================

.Type.java
NOTE: The possible enum values for value are: *CONTEXT*.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Menu.java
----
// Defines a menu with elements home and signup
@Menu
private SideMenu sideMenu;

@Model @Getter @Setter
public static class SideMenu {
	@Link(url="#")
	private String home;

	@Link(url="#")
	private String signup;
}
----

TIP: Decorate complex classes with @Menu to define behavior for child elements (e.g. home and signup in the example above.)

=== Modal

.Modal Attributes
[cols="3,^2,^2,^2,10",options="header"]
|=========================================================
| Name 		| Type 		| Default 		| Required 	| Description

| alias 	| String 	| Modal 		| Y			| Cannot be changed.
| closable	| boolean	| false			| Y			| Specify whether the modal window can be closed.
| context	| ParamContext | @ParamContext(enabled = true, visible = false) | N | Specify the default contextual properties.
| cssClass 	| String	| 				| N			| Override default class.
| title		| String	| 				| N			| Title for the Modal window.
| type 		| Type 		| Type.dialog 	| Y			| Types of modal can be a dialog or a slider.
| width		| String	| 500			| Y			| Width of the modal window

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Modal.java
----
@Modal
private VMMyTasks vmMyTasks;
----

NOTE: Modal is supported only in a tile

==== Setting @Modal to be displayed by default
Modal makes use of **@ParamContext** to by default render it's visible property to false during initialization. We can override this 
functionality by providing our own unique **@ParamContext** values as a parameter of **@Modal**.
----
 public static class SampleView {
 
    @Modal(context = @ParamContext(enabled=true, visible=true))
    private MyModal myModal;
    
    public static class MyModal { ... }
 }
----
In this example, we are creating a modal _myModal_ who's visible property will be true on initialization, and hence will be displayed
when the corresponding page is rendered.

=== MultiSelect

.MultiSelect Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | MultiSelect |cannot be changed
|labelClass |String | anthem-label |class used to style the picklist label
|postEventOnChange |boolean | false |post the value to the server onblur
|help |String | | help text that will be displayed in tooltip component

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.MultiSelect.java
----
@MultiSelect
@Model.Param.Values(url="Anthem/fep/icr/p/clientusergroup/_search?fn=lookup&projection.mapsTo=code:id,label:displayName")
@MapsTo.Path(value="/userGroups", colElemPath="/ownerId")
private List<String> userGroups;
----


=== MultiGrid

.MultiGrid Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | MultiGrid |cannot be changed
|level |String | 0 |class used to style the picklist label
|header |String | test | make the component readonly
|cssClass |String | question-header |class used to style the picklist
|postEventOnChange |boolean | false |post the value to the server onblur

|=========================================================


=== MultiSelectCard

.MultiSelectCard Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | MultiSelectCard |cannot be changed

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.MultiSelectCard.java
----
@MultiSelectCard @NotNull
@Model.Param.Values(url="~/client/orgname/cmprogram/_search?fn=lookup&projection.mapsTo=code:id,label:programName")
@Path(value="/programReferred", colElemPath="/programName")
private List<String> cmProgramList;
----

NOTE: @NotNull indicates that the component cannot be null.

=== Page

.Page Attributes
[cols="3,^2,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Required |Description

|alias |String | Page | Y |Cannot be changed.
|title |String | | N |Specify the page title to be displayed on top of the page.
|cssClass |String | | Y |Custom class used to style the page.
|defaultPage |boolean | false | Y | Determine if the page will be the default page. Default page loads first in a flow.
|route |String |  | N |Specify route of the page.

|=========================================================

NOTE: The possible enum values for type are *HOME, DETAILS, FORM, STATIC*

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Page.java
----
@Page(route="cmcaseR/assignmenttaskview", defaultPage=true)
private Page_AssignmentTask pageAssignmentTask;
----

NOTE: *defaultPage=true* will override the default false value of defaultPage.

=== PickList

.PickList Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | PickList |cannot be changed
|labelClass |String | anthem-label |class used to style the picklist label
|readOnly |boolean |false | make the component readonly
|cssClass |String |  |class used to style the picklist
|postEventOnChange |boolean | false |post the value to the server onblur
|sourceHeader |String | SourceList | specify the source header for the picklist
|targetHeader |String | TargetList | specify the target header for the picklist
|help |String | | help text that will be displayed in tooltip component

|=========================================================

=== Radio

.Radio Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | Radio |cannot be changed
|labelClass |String | anthem-label |class used to style the radio label
|level |String | 0 |determine the level of radio group
|cssClass |String |  |class used to style the radio
|postEventOnChange |boolean | false |post the value to the server onblur
|controlId |String |  |currently not in use except for assessments where this signifies the question number
|help |String | | help text that will be displayed in tooltip component

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Radio.java
----
@Model.Param.Values(url="~/client/orgname/staticCodeValue/_search?fn=lookup&where=staticCodeValue.paramCode.eq('/thisIsParentQuestion14')")
@MapsTo.Path()
@Radio(postEventOnChange=true, controlId = "27")
private String thisIsParentQuestion14;
----

NOTE: *postEventOnChange=true* will override the default false value of postEventOnChange. +
*controlId* is used because in this particular case, there is a question number (27) that is associated with an assessment. +
Please refer Core Config Annotations section for @MapsTo

=== Section

.Section Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |enum | Type.Default| section type
|alias |String | Section |cannot be changed
|imgSrc |String |  | source path/ url of the image
|cssClass |String | | class used to style the section
|defaultFlow |String | | flow of the section

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Section.java
----
@Section
@Path(linked=false)
private SectionEditGoal sectionEditGoal;
----

NOTE: The possible enum values for size are *HEADER, FOOTER, LEFTBAR, RIGHTBAR, BODY, DEFAULT* +
defaultFlow attribute is applicable to section Type.Body only. +
_Please read @Path for more information on @Path._

=== StaticText
[cols="4,^3,^3,10",options="header"]

Directly outputs a raw html content/text value to the view. May use this to bind unsafe HTML directly onto the page. Use wisely.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias					| String 	| StaticText 		| cannot be changed
| controlId				| String 	| 					| currently not in use except for assessments where this signifies the question number

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.StaticText.java
----
@StaticText
private String description;
----


=== SubHeader
[cols="4,^3,^3,10",options="header"]

A header component intended to flow beneath a parent header.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias					| String 	| SubHeader				| cannot be changed
| cssClass 				| String 	| col-sm-6 align-top	| class used to style the component

|=========================================================

=== TextBox

.TextBox Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | TextBox |cannot be changed
|hidden |boolean |false |hide/show the component
|readOnly |boolean |false |make the component readonly
|help |String | | help text that will be displayed in tooltip component
|labelClass |String | anthem-label |class used to style the label
|type |String | text |type of input
|postEventOnChange |boolean | false |post the value to the server onblur
|controlId |String |  |currently not in use except for assessments where this signifies the question number

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.TextBox.java
----
@TextBox(hidden=true)
private String goalId;
----

TIP: In the above example, the default false value of hidden property will be overriden and the textbox will be hidden.
Similarly, other properties can be overriden by specifying the properties and its values along with @Textbox.

=== TextArea
[cols="4,^3,^3,10",options="header"]

A text input component that allows for a specified number of rows.

|=========================================================
| Name 					| Type 		| Default 		| Description

| alias					| String 	| TextArea 		| cannot be changed
| controlId				| String 	| 				| currently not in use except for assessments where this signifies the question number
| help		 			| String 	| 				| help text that will be displayed in tooltip component
| hidden	 			| boolean 	| false 		| hide/show the component
| labelClass	 		| String 	| anthem-label 	| class used to style the label
| postEventOnChange		| boolean 	| false 		| post the value to the server onblur
| readOnly	 			| boolean 	| false			| make the component readonly
| rows	 				| String 	| 5				| type of input
| type	 				| String 	| textarea		| type of input

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.TextArea.java
----
@TextArea
private String description;
----

=== Tile

.Tile Attributes
[cols="3,^2,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Required |Description

|alias |String | Tile | Y |Cannot be changed.
|imgSrc |String |  | N |Source path/ url of the image.
|title |String | | N | Title displayed on top of the tile.
|size |enum | Size.Large | Y | Size of the tile width on the page. +
Size.XSmall - 25% width +
Size.Small - 33% width +
Size.Medium - 50% width +
Size.Large - 100% width

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Tile.java
----
@Tile(size=Tile.Size.Large)
private TileEditGoal tileEditGoal;
----

NOTE: The possible enum values for size are *XSmall, Small, Medium, Large*


=== ViewRoot

.ViewRoot Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | root |cannot be changed
|layout |String | "" |determine layout of root

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ViewRoot.java
----
@Domain(value = "cmcaseview", includeListeners={ListenerType.websocket}, lifecycle="cmcaseview")
@MapsTo.Type(CMCase.class)
@Repo(value=Database.rep_none, cache=Cache.rep_device)
@ViewRoot(layout = "caseoverviewlayout")
@Getter @Setter
public class VRCmCase {
}
----

NOTE: layout of caseoverviewlayout is leveraged here.


.ViewParamBehavior Component

Similar to ViewStyle component, ViewParamBehavior component is used to define an ANNOTATION_TYPE level annotation that is used with few view config annotations,
as follows: - +

 - @Hints
 - @Initialize
 - @Mode
 - @PageHeader
 - @PageFooter

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target(value={ElementType.ANNOTATION_TYPE})
	@Inherited
	public @interface ViewParamBehavior {

	}
----

Here is an example: -

[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.FIELD})
	@ViewParamBehavior
	public @interface Initialize {
		String alias() default "initialize";
	}
----

==== PageFooter

.PageFooter Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |enum | Property.Default | property of PageFooter

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.PageFooter.java
----
@PageFooter(Property.VERSION)
private String appVersion;
----

NOTE: The possible Property enum values for value are *DEFAULT, TOU, VERSION, COPYRIGHT, SSLCERT, PRIVACY*

==== PageHeader

.PageHeader Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |enum | Property.Default | property of PageHeader

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.PageHeader.java
----
@PageHeader(Property.USERNAME)
private String fullName;
----

NOTE: The possible Property enum values for value are *DEFAULT, LOGO, APPTITLE, SUBTITLE, USERNAME, USERROLE, SUBHEADER, MENU*

==== Initialize

.Initialize Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|alias |String | initialize | cannot be changed

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Initialize.java
----
@Section
@Initialize
@Config(url="/vpAdvancedMemberSearch/vtAdvancedMemberSearch/vsMemberSearchCriteria/vfAdvMemberSearch/_process?fn=_setByRule&rule=updateadvmbrsearchcriteria")
private VSMemberSearchCriteria vsMemberSearchCriteria;
----

==== Mode

.Mode Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |enum | Options.INHERIT | OPtions of Mode

|=========================================================

NOTE: The possible Property enum values for value are *INHERIT, READONLY, HIDDEN*


==== Hints

.Hints Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |enum | AlignOptions.Inherit | Align optinons of Hints

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Hints.java
----
@Link(url="/#/h/cmdashboard/vpDashboard", imgSrc="anthem-rev.svg")
@Hints(AlignOptions.Left)
@PageHeader(Property.LOGO)
private String linkHomeLogo;
----

NOTE: The possible Property enum values for value are *INHERIT, LEFT, RIGHT, CENTER*


.DomainMeta Component

Similar to ViewStyle component, DomainMeta component is used to define an ANNOTATION_TYPE level annotation that is used with few view config annotations,
as follows: - +

 - @ConceptId

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target(value={ElementType.ANNOTATION_TYPE})
	@Inherited
	public @interface DomainMeta {

	}
----

Here is an example: -

[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Retention(RetentionPolicy.RUNTIME)
	@Target({ElementType.FIELD})
	@DomainMeta
	public @interface ConceptId {
		String value() default "";
	}
----


==== ConceptId

.ConceptId Attributes
[cols="3,^2,^2,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |String | "" | possible value for conceptId

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ConceptId.java
----
@TextBox(postEventOnChange = true)
@ConceptId(value = "IOT1.1.1")
@Label(value = "If Other, provide reason")
private String otherReason;
----


== Core Config Annotations

=== AccessConditional
@AccessConditional allows to control the access of the specific area/functionality within the application based on User's assigned role(s) and permission(s).

Example:

[source,java,indent=0]
[subs="verbatim,attributes"]
----
@AccessConditional(whenAuthorities="?[#this == 'entity_assign'].empty", p=Permission.HIDDEN)
private Section_EntityAssignment vsEntityAssignment;
----
Above configuration would hide the entity assignment section for user(s) who do not have access to "entity_assign" action.

.AccessConditional Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type			 | Default			 | Description

| whenAuthorities			| String		 | 					 | SpEL (spring expression language) to check for user permissions **Recommended**
| whenRoles			| String		 | 					 | SpEL (spring expression language) to check for user roles
| containsAuthorites			| String[]		 | 					 | Simple contains check for user permissions. (for more complex conditions, use _whenAuthorities_)
| containsRoles			| String[]		 | 					 | Simple contains check for user roles. (for more complex conditions, use _whenRoles_)
|=========================================================

CAUTION: **_whenRoles_** and **_containsRoles_** should be used with caution, since roles may be added/changed more frequently in the application and in that event, you would need to update the entity configurations.

More Examples:

[source,java,indent=0]
[subs="verbatim,attributes"]
----
// vbEntityCreate will be hidden for user(s) who do not have access to "entity_create"
@AccessConditional(whenAuthorities="?[#this == 'entity_create'].empty", p=Permission.HIDDEN)
private Button_EntityCreate vbEntityCreate;

//vsEntityEdit will be hidden for user(s) who do not have access to "entity_create" or "entity_edit"
@AccessConditional(whenAuthorities="?[#this == 'entity_create'].empty && ?[#this == 'entity_edit'].empty", p=Permission.READ)
private Section_EntityEdit vsEntityEdit;
----

==== AccessConditionals
@AccessConditionals is a collection of AccessConditional calls.

.AccessConditionals Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |AccessConditional[] |  |

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.AccessConditionals.java
----
	@AccessConditionals({
		@AccessConditional(whenAuthorities="!?[#this == 'entity_management'].empty || !?[#this == 'entity_create'].empty", p=Permission.READ)
		@AccessConditional(whenAuthorities="?[#this == 'entity_management'].empty && ?[#this == 'entity_create'].empty", p=Permission.HIDDEN)
	})
	private String entity_accessConditionals;
----

=== ActivateConditional

Activate Conditional is an extension capability provided by the framework. The annotation is used to conditionally activate/deactivate the param based on a SpEL condition.
This annotation can be triggered for multiple events. Framework provides default event handling for this annotation on StateChange and StateLoad.

.ActivateConditional Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|when |String | |SpEL based condition to be evaluated relative to param's state on which this annotation is declared.
|targetPath|String[] | | Path of param to activate when condition is satisfied relative to param on which this annotation is declared. Multiple target paths can be given
|inactivateWhen|String | emptyString|SpEL based condition on which param would be inactivated.If value is not overridden, then the negation of ActivateConditional#when() would be used
|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ActivateConditional.java
----
@CheckBox(postEventOnChange=true)
@ActivateConditional(when="state != 'true'", targetPath="/../sectionG_skip")
private String skipSectionG;

private sectionG_Skip sectionG_skip;

@Radio(postEventOnChange=true)
@Model.Param.Values(value=YNType.class)
@ActivateConditional(when="state == 'No'", targetPath="/../q3Level2")
private String answerYesOrNo;

private Q3 q3Level2;

@CheckBoxGroup(postEventOnChange=true)
@Model.Param.Values(value=Days.class)
@ActivateConditional(when="state == new String[]{'Sunday'}",targetPath="/../../../sundayDeliverySection")
private String[] deliveryDays;

/*Check if selection contains one or more specific values*/
@CheckBoxGroup(postEventOnChange=true)
@Model.Param.Values(value=Days.class)
@ActivateConditional(when="state != null && state.?[#this=='Sunday'] != new String[]{}",targetPath="/../../../sundayDeliverySection")
private String[] deliveryDays;

@CheckBoxGroup(postEventOnChange=true)
@Model.Param.Values(value=VisitCount.class)
@ActivateConditional(when="state != null && state.length > 2",targetPath="/../../section")
private String[] visits;
----
Example SpEL expressions:
[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
//Contains single element:
@ActivateConditional(when="state != null && state.?[#this=='Apple'] != new String[]{}", targetPath = {"/../xyz","/../abc"})
//Contains exactly one single element:
@ActivateConditional(when="state == new String[]{'Apple'}", targetPath = {"/../xyz","/../abc"})
//Evaluate multiple or conditions
@ActivateConditional(when="state!=null && state.?[#this=='Apple' || #this=='Google'] != new String[]{}",targetPath="/../")

==== ActivateConditionals
@ActivateConditionals is a collection of ActivateConditional calls.

.ActivateConditionals Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |ActivateConditional[] |  |

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ActivateConditionals.java
----
	@ActivateConditionals({
		@ActivateConditional(when="state == 'A'", targetPath="/../q3Level1"),
		@ActivateConditional(when="state == 'B'", targetPath="/../q3Level2")
	})
	private String q3;
	private SampleCoreNestedEntity q3Level1;
	private SampleCoreNestedEntity q3Level2;
----
=== Config

.Config Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|url |String |  |

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Config.java
----
@Config(url="/pageAddEditGoal/tileEditGoal/sectionEditGoal/goalDetailsForm/_nav?pageId=pageCarePlanSummary")
@Button(type = Button.Type.PLAIN)
private String cancel;
----

A class with @Config annotation is used to perform an action on button click.
In most cases, the action is to retrieve values via HTTP Rest calls
from database (MongoDB), and display on the web page. +

In the example shown above, when the button is clicked, the control will be navigated to the specified url. +
_nav_ is the http call for navigation. +

The possible Actions are: - +

 - get for HTTP GET
 - new for HTTP post
 - update for HTTP update
 - delete for HTTP delete
 - search for searching
 - nav for navigation
 - process for custom process/ work-flow definitions


==== Configs

.Configs Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|values |Config[] |  |

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Configs.java
----
@Configs({
@Config(url="~/client/org_name/_update"),
@Config(url="~/client/org_name/_process?fn=_set&url=/p/cmcase/_search?fn=query&where=cmcase.patientReferred.firstName.eq('<!/.m/patientReferred/firstName!>').and(cmcase.patientReferred.lastName.eq('<!/.m/patientReferred/lastName!>'))"),
@Config(url="~/client/org_name/_nav?pageId=vpAdvancedCaseSearch")
		})
@Button(type=Button.Type.PRIMARY, formReset=false)
private String submit;
----

@Configs is a collection of configuration calls. Multiple calls to the database
can be made simultaneously using @Configs, where each call will be represented by @Config. +

As shown in the example, when the submit button is clicked, three http calls that are being made viz.
update, process, and navigation.

=== ConfigConditional
ConfigConditional is an extension capability provided by the framework. The annotation is used to conditionally execute @Config calls based on a SPel based condition.
This annotation can be triggered for multiple events. Framework provides default event handling for this annotation on StateChange.

.ConfigConditional Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|when |String | |SpEL based condition to be evaluated relative to param's state on which this annotation is declared.
|config|Config[] | emptyString| Array of @Configs
|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ConfigConditional.java
----
@ConfigConditional(
	when = "state == 'Completed'", config = {
	@Config(url="<!#this!>/../state/_update?rawpayload=\"Closed\""),
	@Config(url="/p/dashboard/_get")
})
private String status;
----
NOTE: In the above example , whenever there is statechange of status and the status is changed to *Completed*, the Configs will be executed.

=== ConfigNature

==== Ignore

Framework persists the data objects of a class in database using @Repo by serializing the class and associating a version number that is called seriaVersionUID.
However, if we do not want the framwework to serialize for time being, we can use @Ignore component of ConfigNature class. The following example shows that: -

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.StartsWith.java
----
@Domain(value="patient", includeListeners={ListenerType.persistence})
@Repo(value=Database.rep_mongodb, cache=Cache.rep_device)
@ToString
public class Patient extends IdString {

	@Ignore
	private static final long serialVersionUID = 1L;

	}
----

=== Domain

Core Config configuration @Domain annotation persists data. +

Core config @Domain will always be followed by @Repo that will specify the way data is persisted. +

*includeListeners={ListenerType.persistence, ListenerType.update}* of @Domain
specifies that the data will be persisted. +
*value=Database.rep_mongodb* of @Repo specifies that a class with
@Domain annotation will use MongoDb for persistence.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Domain.java
----
@Domain(value="cmcase", includeListeners={ListenerType.persistence, ListenerType.update})
@Repo(value=Database.rep_mongodb, cache=Cache.rep_device)
public class CMCase extends IdString {
}
----

NOTE: Please read @Repo for mroe information regarding @Repo annotation.

=== EnableConditional
EnableConditional is an extension capability provided by the framework. The annotation is used to conditionally activate/deactivate the param based on a SpEL condition. This annotation can be triggered for multiple events. Framework provides default event handling for this annotation on StateChange and StateLoad.
The difference between this annotation and @ActivateConditional is this annotation only affects the "enabled" state whereas @ActivateConditional affects both "enabled" and "visible" state.

.EnableConditional Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|when |String | |SpEL based condition to be evaluated relative to param's state on which this annotation is declared.
|targetPath|String[] | | Path of param to enable when condition is satisfied relative to param on which this annotation is declared
|disableWhen |String | | SpEL based condition on which param would be disabled. If value is not overridden, then the negation of EnableConditional#when() would be used 
|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.EnableConditional.java
----
	@EnableConditional(when="state == 'hooli'", targetPath="../enable_p2")
	private String enable_p1;
	
	private String enable_p2;
----

==== EnableConditionals
@EnableConditionals is a collection of EnableConditional calls.

=== Exection
Execution is inherited annotation for @Config and @KeyValue. It is not currently being directly used, but is there for hieracrchial purposes.

More documentation will be added here if Execution expands or is directly used.

=== MapsTo

==== Path

.Path Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |String |  |specify value of Path
|colElemPath |String | DEFAULT_COL_ELEM_PATH | specifies column element path
|state |State | State.Internal | specifie path state
|linked |boolean |true | determine if the path has links
|cache |Cache | Cache.rep_device | specifies cache type

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Path.java
----
@Path()
private Long version;
----


==== Type

.Type Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |class<?> | |
|silent |boolean | true |determines if Type is silent

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Type.java
----
@MapsTo.Type(CMCase.class)
public static class SectionEditGoal  {
    }
----

NOTE: If it is not mapped _(@Mapped)_, an exception will be thrown. +
If no exception is thrown, defaults to silent.


=== Model

==== Param

.Param Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |Class<? extends Source> | Source.class |specify value of Path
|url |String | staticCodeValue | specifies url

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Param.java
----
@Model.Param.Values(url="~/client/orgname/staticCodeValue/_search?fn=lookup&where=staticCodeValue.paramCode.eq('/thisIsParentQuestion14')")
@Radio(postEventOnChange=true, controlId = "27")
private String thisIsParentQuestion14;
----

NOTE: The example will retrieve the value of Radio button from the specified url. +
*staticCodeValue* is a collection in MongoDB that will be searched and retrieved using @Model annotation.
The search criteria is specified using param code _thisIsParentQuestion14_


==== Text

.Text Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|label |String | |

|=========================================================

=== ParamContext

**@ParamContext** is used to set the contextual properties of a field during the _OnStateLoad_ event (e.g. _visible_, _enabled_). 

.ParamContext Attributes
[cols="3, 3, 3, 10",options="header"]
|=========================================================
| Name 			| Type			| Default	 | Description

| visible		| boolean		| 			 | Whether or not the decorated target should be visible.
| enabled		| boolean		|			 | Whether or not the decorated target should be enabled.
|=========================================================

The intent of **@ParamContext** is to be able to decorate fields to define default contextual behavior. For example:

[source,java,indent=0]
[subs="verbatim,attributes"]
.SampleView.java
----
 public static class SampleView {
 
    @TextBox
    @ParamContext(enabled=false, visible=false)
    private String myTextBox;
 }
----

In this scenario we have configured the contextual values for _enabled_ and _visible_ to be **false** for _myTextBox_. These values will 
be set during the _OnStateLoad_ event and _myTextBox_ consequently will not be enabled or visible when the corresponding page is rendered.

TIP: **@ParamContext** can also be defined on annotations. In these scenarios when a field is decorated with that annotation, then the 
handler for **@ParamContext** will execute. This may be useful when building a framework extension.

=== SearchNature

==== StartsWith

This component is ued to validate a field. The wilcard attribute determines the validation criteria for a field. This is a server side component.

.StartsWith Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|wildCard |String | * |determines the search criteria

|=========================================================

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.StartsWith.java
----
@NotNull
@StartsWith
@Label(value = "First Name")
private String firstName;
----

NOTE: The example will always search the first name that starts with anything, represented with the default value. A specific search criteria can be
specified using wildcard attribute of @StartsWith.

=== Repo

.Repo Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description
|alias |String | | cannot be changed
|value |enum |  |specify value of Path
|cache |enum | Cache.rep_device | specifies cache type
|autoSave |boolean |true | determine if the autosave is enabled

|=========================================================

NOTE: The possible enum values for value are *DATABASE.rep_none, DATABASE.rep_rdbms, DATABASE.rep_mongodb, DATABASE.rep_ws* +
The possible enum values for cache are *CACHE.rep_none, CACHE.rep_device*

@Repo is used to determine where the data will be persisted. It is always used along with @Domain. +

==== rep_mongodb

The following example shows how data is persisted/ retrieved using MongoDB as a source.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Repo.java
----
@Domain(value="cmassessment", includeListeners={ListenerType.persistence})
@Repo(alias="cmassessment",value=Database.rep_mongodb, cache=Cache.rep_device)
@Getter @Setter
public class CMAssessment extends IdString {
}
----

==== rep_ws

Databse values can be persisted/ retrieved not only using internal MongoDb as a source, we can now use an external web service for the same purpose.
All we have to do is create a REST call to a web service that will provide or store the data. Following is an example: -

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.ExtClient.java
----
@Domain(value="ext_client")
@Repo(value=Database.rep_ws, cache=Cache.rep_device)
@Getter @Setter @ToString(callSuper=true)
public class ExtClient {

}
----

Notice *@Repo(value=Database.rep_ws)* in the code above. This indicates that it will make use of an external web service call rather than
a MongoDb call for ExtClient data objects' persistence/ retrieval purposes.

The advantage of this feature is that now we do not rely on internal source only. This gives us better flexibility and maintainability

=== Rule

@Rule allows its decorated field a mechanism for triggering one or more rule definitions during its OnStateLoad and OnStateChange events.

[source,java,indent=0]
[subs="verbatim,attributes"]
.SampleRuleEntity.java
----
@Domain(value="sample_rule_entity", includeListeners={ListenerType.persistence})
@Repo(Database.rep_mongodb)
@Getter @Setter
public class SampleRuleEntity {

	// Execute the rule at "rules/sample_increment" during the OnStateLoad and
	// OnStateChange events of ruleParam.
	@Rule("rules/sample_increment")
	private String rule_param;
}
----

By default, the framework provides support for firing all rules for a given domain entity. That is, for the *SampleRuleEntity.java* above we might have a rule file defined as *sample_rule_entity.drl* which will be automatically fired by naming convention.

For cases where additional configuration for other rules is needed, @Rule can be used.

.Rule Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type			 | Default			 | Description

| value			| String[]		 | 					 | rule file path(s) to execute.
|=========================================================

=== Values
Values provides a mechanism for populating a fields _values_ property. This can be used by a number of components
to perform such functions as: define a set of selections for radio buttons and checkboxes, or populating a dropdown list.

.Values Attributes
[cols="3, 5, 3, 10",options="header"]
|=========================================================
| Name 			| Type			 				| Default			 | Description

| value			| Class<? extends Source>		| EMPTY				 | Source implementation that returns a list of **ParamValues**
| url			| String						|					 | url endpoint that returns a list of **ParamValues**
|=========================================================

NOTE: _value_'s default value is **EMPTY**, which is a simple Source implementation that returns an empty list of **ParamValues**.

==== Source
The Source is a simple abstraction for providing a contract between implementations to provide data to the framework. 

Source is exclusively used for **@Values**.

[source,java,indent=0]
[subs="verbatim,attributes"]
.Source.java
----
public static interface Source {
	public List<ParamValue> getValues(String paramCode);
}
----

We can use this to define several different types of values providers. A simple static Source implementation is shown below:

[source,java,indent=0]
[subs="verbatim,attributes"]
.SampleStaticSource.java
----
public class SampleStaticSource implements Source {
	public List<ParamValue> getValues(String paramCode) {
		List<ParamValue> values = new ArrayList();
		values.add(new ParamValue("sample.value.1", "Sample Value 1"));
		return values;
	}
}
----

==== Examples

.Using a static Source implementation to define a set of values
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Values(SampleStaticSource.class)
@CheckBoxGroup
private String petTypes;
----

In this example, all of the values retrieved from SampleStaticSource.getValues will be displayed as a collection of checkboxes.

.Using a url-based Source implementation to define a set of values
[source,java,indent=0]
[subs="verbatim,attributes"]
----
@Values(url="CLIENT_ID/ORG/p/staticCodeValue/_search?fn=lookup&where=staticCodeValue.paramCode.eq('/petType')")
@CheckBoxGroup
private String petTypes;
----

In this example, all of the values retrieved from the url defined in **@Values** will be displayed 
as a collection of checkboxes.

=== ValuesConditional

ValuesConditional is an extension capability provided by the framework. The annotation is used to conditionally set the @Values configuration for a dependent field
based on a SpEL condition. This annotation can be triggered for multiple events. Framework provides default event handling for this annotation on StateChange and StateLoad.

.ValuesConditional Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type			 | Default			 | Description

| target		| String		 | 					 | The target path relative to the this annotated field to update.
| condition		| Condition[]	 |					 | An array of conditional metadata that is responsible for determining whether or not the target field will be updated.
| resetOnChange	| boolean		 | true				 | When **true** and the associated _when_ expression evaluates to **true**, the _state_ of _target_ will be set to null. When **false** and the associated _when_ expression evaluates to **true**, the _state_ of _target_ will be set to null only when the previously existing _target_'s _state_ does not exist in the _then_'s **@Values** property. Otherwise, the existing _state_ will be preserved.
| exclusive		| boolean		 | true				 | Configures whether or not the first truthy condition should be exclusive. If true, then only the first truthy condition will be executed. If false then all truthy conditions will be executed. the default value is true.
|=========================================================

.Condition Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
| Name 			| Type			 | Default			 | Description

| when			| String		 | 					 | SpEL based condition to be evaluated relative to param's state on which this annotation is declared.
| then			| Values		 |					 | Values configuration to be applied to the param identified by the target path when this condition's when clause is found to be true.
|=========================================================

Consider the following sample defined Values:

[source,java,indent=0]
[subs="verbatim,attributes"]
.SampleValues.java
----
// Sample Values Implementations
public static class SRC_FOODS_ALL implements Source {
	@Override
	public List<ParamValue> getValues(String paramCode) {
		final List<ParamValue> values = new ArrayList<>();
		values.add(new ParamValue("Generic Food 1", "Generic Food 1"));
		values.add(new ParamValue("Generic Food 2", "Generic Food 2"));
		return values;
	}
}
public static class SRC_FOODS_DOG implements Source {
	@Override
	public List<ParamValue> getValues(String paramCode) {
		final List<ParamValue> values = new ArrayList<>();
		values.add(new ParamValue("Dog Food 1", "Dog Food 1"));
		return values;
	}
}
public static class SRC_FOODS_CAT implements Source {
	@Override
	public List<ParamValue> getValues(String paramCode) {
		final List<ParamValue> values = new ArrayList<>();
		values.add(new ParamValue("Cat Food 1", "Cat Food 1"));
		return values;
	}
}
----

Given a defined set of Values that we can assign using the @Values annotation, we can explicitly define conditions to set a dependent field's values.

[source,java,indent=0]
[subs="verbatim,attributes"]
.ValuesConditional.java
----
@Model
@Getter @Setter
public static class StatusForm {

	@ValuesConditional(target = "../petFoodSelection", condition = {
			@Condition(when = "state=='dog'", then = @Values(SRC_FOODS_DOG.class)),
			@Condition(when = "state=='cat'", then = @Values(SRC_FOODS_CAT.class)),
		}
	)
	@TextBox(postEventOnChange = true)
	private String petType;

	@Radio
	@Values(SRC_FOODS_ALL.class)
	private String petFoodSelection;
}
----

In this example, _petType_ is the field and _petFoodSelection_ is the dependent field. We set _petFoodSelection_ to contain the defaults ["Generic Food 1", "Generic Food 2"] initially and conditionally define those values when _petType_'s state is "dog" or "cat".

When the state of _petType_ is "dog", then the Values for _petFoodSelection_ will be ["Dog Food 1"]. Similarly when the state of _petType_ is "cat", then the Values for _petFoodSelection_ will be ["Cat Food 1"].

Conceptually speaking, we are *pushing* the updates of Values to the dependent field whenever the state of the annotated field loads or is changed.

==== ValuesConditionals
@ValuesConditionals is a collection of ValuesConditional calls.

The framework has the capability for a field to define ValuesConditional to affect multiple dependent fields.

.ValuesConditionals Attributes
[cols="4,^3,^3,10",options="header"]
|=========================================================
|Name | Type |Default |Description

|value |ValuesConditional[] |  |

|=========================================================

[source,java,indent=0]
[subs="verbatim,attributes"]
.ValuesConditionals.java
----
@Model
@Getter @Setter
public static class StatusForm {

	@ValuesConditionals({
		@ValuesConditional(target = "../petFoodSelection", condition = {
				@Condition(when = "state=='dog'", then = @Values(SRC_FOODS_DOG.class)),
				@Condition(when = "state=='cat'", then = @Values(SRC_FOODS_CAT.class)),
			}
		),
		@ValuesConditional(target = "../petFoodSelection2", condition = {
				@Condition(when = "state=='dog'", then = @Values(SRC_FOODS_DOG.class)),
			}
		)
	})
	@TextBox(postEventOnChange = true)
	private String petType;

	@Radio
	@Values(SRC_FOODS_ALL.class)
	private String petFoodSelection;

	@Radio
	private String petFoodSelection2;
}
----

In this example, we have two dependent fields: _petFoodSelection_ and _petFoodSelection2_. Note that nothing has changed for the _petFoodSelection_ field from the previous example, but we have set a @ValuesConditional for the dependent field _petFoodSelection2_ that when the state of _status_ is "dog", the Values of _petFoodSelection2_ will be ["Dog Food 1"].

== View Component(s)

=== Tooltip

This is a new custom component that is added in the framework to provide additional information about all the input fields that are used within the
application. The input fields are the fields that require user selection like textbox, textarea, combobox, checkbox, input date etc.
In order to create a tooltip component for a particular field, all that is required is to add a help attribute in the field configuration.
Please look at the following example: -

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Tooltip.java
----
@Radio(postEventOnChange = true, help="This field requires a value for pet type")
private String petType;
----

NOTE: The tooltip component will be created for this field and will display the specified value in the help field.

== UI Validation

=== JSR Annotations
Support has been added for JSR 303 type annotations. All annotations inheriting from _javax.validation.Constraint_ will be picked up and
added to a configured parameter's configuraton.

Specific support within the UI has been added for the following javax.validation annotations

.Supported Constraint Annotations
[cols="3,10", options="header"]
|=========================================================
| Name 				| Description

| @NotNull 			| Requires that a field should not have a null value.
| @Pattern			| Requires that a field follow a specific regex pattern.
| @Min				| Requires that a minimum value should be provided.
| @Max				| Requires that a maximum value should be provided.
| @Size				| Requires that a specific range should be provided. Useful for component groups.

|=========================================================

==== Special Considerations

.@Size
* When used in conjunction with **@CheckBoxGroup**, **@Size** will require the given number (_min_) of checkboxes to be selected or will limit the given number (_max_) of checkboxes that are able to be selected.

==== Custom Messages
The framework has the ability to pass custom validation messages from within JSR Annotations to the UI.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Repo.java
----
@NotNull(message = "First name should not be empty.")
private String status;
----

Here, if the UI field 'status' is left blank by the user, "First name should not be empty" message would be displayed. @NotNull will just display the default message.

== Layout Configuration


As you can see in the screenshot above, the layout of the application is
divided into 3 sections viz. Header, Footer, and Leftbar. Please read the code
below to understand the way the sections has been created.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Repo.java
----
public static class VPHome {

@Section(Type.HEADER)
private VSHomeHeader vsHomeHeader;

@Section(Type.LEFTBAR)
private VSHomeLeftBar vsHomeLeftBar;

@Section(Type.FOOTER)
private VSHomeFooter vsHomeFooter;

	}
----

NOTE: @Section(Type.*_value_*) determines the section on the page. This code shows
three of the _type_ values for @Section. For more values, please refer to the @Section
annotation within View Config Annotations.


== Collection Configuration

Collection configuration is introduced in the framework to eliminate the creation and use of different functional handlers for adding, editing and deleting
elements from/ to a collection. This structure now gives us the ability to work on any of these functions on any of the elements from a collection at any given time.

This configuration is explained using a use case of a Car. A user might want to see a Car home page that has list of cars. User may be able to add, edit, or delete
cars and also view properties of car. The first step is to create a core domain entity.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CarEntity.java
----
@Domain(value="Car", includeListeners={ListenerType.persistence})
@Repo(Database.rep_mongodb)
@Getter @Setter
public class CarEntity extends IdString {

	private String attr_String;

	private int attr_int;
	private Integer attr_Integer;

	private CarNestedEntity attr_CarNestedEntity;

	private List<CarNestedEntity> attr_list_2_CarNestedEntity;

	}
----

This configuration provides us with the flexibility such that we can define a custom set of car features to be displayed. The features are defined in the
nested entity as shown in the code below: -

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CarNestedEntity.java
----
@Model
@Getter @Setter
public class CarNestedEntity {

	private String car_name;
}
----

The following class defines the home page that will show a list of cars. Notice the way in which the nested entities are mapped to its property.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.VPCarHome.java
----
@MapsTo.Type(CarEntity.class)
@Getter @Setter
public class VPCarHome {

	@Tile(title="Car Home", size=Tile.Size.Large)
	private TileBlue tile;

	@MapsTo.Type(CarEntity.class)
	@Getter @Setter
	public static class TileBlue {

		// add new Nested Entity
		@Configs(
			@Config(url="/page_red/tile/vt_attached_convertedNestedEntity/_get?fn=param&expr=assignMapsTo('../.m/attr_list_2_CarNestedEntity')")
		)
		private String addButton;

		// view/edit mapped collection to core
		@Path(value="/attr_list_2_CarNestedEntity")
		private List<Section_ConvertedNestedEntity> vm_attached_convertedList;

    }

	@MapsTo.Type(CarNestedEntity.class)
	@Getter @Setter
	public static class Section_ConvertedNestedEntity {

		// assigning collection element of core to Form
		@Configs(
			@Config(url="/page_red/tile/vt_attached_convertedNestedEntity/_get?fn=param&expr=assignMapsTo('/.d/<!#this!>/../.m')")
		)
		private String editButton;

		@Path("/car_name")
		private String vm_car_name;
	}

}
----

As you can see, when you click on addButton, the config url will follow the domain model path until the form view where a user can save the new car (nested entity),
and then switch from view config to core config using .m to assign a new car to attr_list_2_CarNestedEntity list.
The Section_ConvertedNestedEntity is a nested entity that is used to view/ edit collection that is mapped to core, using edit button and vm_car_name respectively.
The edit button that has a config url that will be resolved in a similar way to that of add button, however, as you can see, there is a .d that signifies the
mapping to the core domain model i.e. it will point to the root which is CarEntity.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.VPCarDetails.java
----
@MapsTo.Type(CarEntity.class)
@Getter @Setter
public class VPCarDetails {

	@Tile(title="Car Details", size=Tile.Size.Large)
	private TileRed tile;

	@MapsTo.Type(CarEntity.class)
	@Getter @Setter
	public static class TileRed {

		@Path(value="/attr_list_2_CarNestedEntity", nature=Nature.TransientColElem)
		private Form_ConvertedNestedEntity vt_attached_convertedNestedEntity;
	}

	@MapsTo.Type(CarNestedEntity.class)
	@Getter @Setter
	public static class Form_ConvertedNestedEntity {

		@Configs(
			@Config(url="<!#this!>/../_update")
		)
		private String saveButton;

		@Configs({
			@Config(url="<!#this!>/../.m/_delete"),
			@Config(url="<!#this!>/../_get?fn=param&expr=unassignMapsTo()")
		})
		private String deleteButton;

		@Path("/car_name")
		private String vt_car_name;
	}

}
----

This is the car details page that will be displayed when user clicks on add/ edit button from the Home page. This is used to create another nested entity,
however, please notice *nature=Nature.TransientColElem*. This property is used to determine that Form_ConvertedNestedEntity have transient relationship
with the Car (core entity). Form_ConvertedNestedEntity will display the car property (car name) and two buttons viz. save and delete to perform add/edit and
delete functions respectively.

Hence, by using the collection configuration, we can eliminate the use of add/edit/delete custom functional handlers to perform add/edit/delete functions respectively.


== Rule Configuration

Framework comes with support for Drools Rules (https://www.drools.org/) engine out of the box. The rules can be defined at multiple levels.

.Where can rules be configured?
* **Entity Level**: Rules defined at the entity level gets triggered everytime the entity is updated. Typically business rules that manage the entity state would be defined at this level. The framework would pick any rule with the extension <domainalias>.drl and associate with the entity updates. The rule would have access to the entity domain that it is being executed.
* **Function Handler Level**: Business rules that can span across multiple entities or needs to be controlled based on business flow rather than everytime entity is updated can be configured using Function handler. Please refer to the link:Documentation.html#_function_handlers[Function Handler documentation] for more information on configuring these rules.
* **Attribute Level**: Activation and deactivation at attribute level based on certain conditions can be handled using @ActivateConditional annotation. Please refer to the link:Documentation.html#_activateconditional[ActivateConditional documentation] for more information.
* **Configuration Level:**  Individual fields can be annotated with **@Rule** so that a particular rules file(s) will be executed. Please refer to the link:Documentation.html#_rule[Rule documentation] for more information.

== Audit
.Framework has the ability to create an Audit Configuration for leaf parameters to generate audit history on state change of the annotated parameter.
When a leafParam is annotated with @Audit, based on the event handler defined for the annotation, the audit history is created for that particular leafParam.
By default, the @Audit functionality is invoked for OnStateChange event handlers.

Usage : @Audit(AuditHistory.class)

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.Car.java
----
@Audit(SampleCarAuditEntry.class)
private String audit_String;

@Audit(SampleCarAuditEntry.class)
private Integer audit_Integer;

@Audit(SampleCarAuditEntry.class)
private String unmapped_String;

----

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.VPCar.java
----
@Audit(SampleCarAuditEntry.class)
@Path
private String audit_String; // mapped and marked with Audit on both view & core

@Audit(SampleViewCarAuditEntry.class)
private String unmapped_String; // unmapped and marked with Audit on a quad with persistent core

@Path
private Integer audit_Integer; // mapped view to a core which is annotated with Audit

----
As you can see @Audit can be annotated on both view and core entities.

== Process Configuration

=== Business Process Configuration
include::BPMConfiguration.adoc[]

=== Function Handlers
**Function Handlers** are an abstraction within the framework to execute a common set of instructions for a given **Action**.

Given an action, a particular function handler can be executed by specifying a value for the query parameter **fn**.

.Example configuration for a _set function handler
[source,java]
----
@Config(url="/p/patient:<!/.m/id!>/_process?fn=_set")
----

In the example above, **_process_** is the **Action** and **_set_** is the Function Handler we have configured to execute as a part of this **@Config** configuration.

==== Predefined Function Handlers

There are several default function handlers defined within the core framework to handle common framework instructions, such as setting the state of a parameter (**_set_**) or adding a parameter value into a collection (**_add_**).

The following function handlers are provided out-of-the-box:

.Predefined Function Handlers
[options="header", cols="1, 1, 4"]
|=========================================================
| Handler 			| Action		| Description

| _param			| _get			|
| _default			| _nav			|
| _initEntity		| _new			|
| _add				| _process		| Adds parameter value to a collection.
| _addCollection	| _process		|
| _bpm				| _process		| Invokes a statless bpm process.
| _eval				| _process		|
| _set				| _process		| Sets parameter value.
| _setByRule		| _process		| Set parameter value through a rule.
| _example			| _search		|
| _lookup			| _search		|
| _query			| _search		|

|=========================================================

==== Custom Function Handlers

The framework provides the ability to users to define custom function handlers.

To create a custom function handler, create a **@Bean** to be injected in the spring context which implements **FunctionHandler** class from the framework.
Below are two samples for creating custom handlers.

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.PetClinicExtensionConfig.java

@Configuration
public class PetClinicExtensionConfig {
	@Bean(name="default._process$execute?fn=_custom")
	public CustomFunctionHandler<?,?> setCustomFunctionHandler(BeanResolverStrategy beanResolver) {
		return new CustomFunctionHandler<>(beanResolver);
	}
	@Bean(name="petclinic._process$execute?fn=_setByRule")
	public SetByRuleFunctionHandler<?,?> setByRuleFunctionHandler() {
		return new SetByRuleFunctionHandler<>();
	}
}

Custom implementation example:

[[app-listing]]
[source,java,indent=0]
[subs="verbatim,attributes"]
.CustomFunctionHandler.java
----
public class CustomFunctionHandler<T,S> implements FunctionHandler<T,S> {
	public CustomFunctionHandler(BeanResolverStrategy beanResolver) {}
	@Override
	public S execute(ExecutionContext eCtx, Param<T> actionParameter) {
		/**
		 * Add custom function handler logic here
		 **/
		return null;
	}
}
----
Usage: **@Config(url="/vpOwners/vtOwners/vsSearchOwnerCriteria/vfSearchOwnerCriteria/vbgSearchOwner/\_process?fn=\_custom")**

.Notes
* Naming convention for the bean name should to be followed for the custom function handler to be recognized by the framework - **<default>.\_process$execute?fn**
* <default> is used for the default implementation of framework.
It can be overwritten by specific implementations of the function handler by replacing <default> with ex. petclinic

include::Querydsl.adoc[]

== View Configuration
include::ViewConfiguration.adoc[]

== Infrastructure
image::application-setup.jpeg[Infrastructure]
